- Оптимизация NodeId/NodeOutId (память расходуется неэффективно)
- Пробрасывать node_id внутрь outputs (тогда не нужно передавать в `node_out_id()`)
- Вместо Vec<BitVecMask> завести более компактное представление
- Добавить макросы для "функционального" пайплайна и отслеживания сигналов:
вместо:
```rust
self.and_then(move |signal| {
    let signal = signal.watch("is_rising::signal");
    let old_signal = {
        let signal = signal.clone();
        reg(clk, rst, T::MIN, move |_| {
            let old_signal = signal.value();
            if old_signal == T::MIN {
                T::MAX
            } else {
                T::MIN
            }
        })
        .watch("is_rising::old_signal")
    };

    apply2(signal, old_signal, |signal, old_signal| {
        signal == T::MAX && signal == old_signal
    })
})
.map(Bit::from)
.watch("is_rising::output")
```
использовать:
```rust
  #[watch]
  signal
    |>> move |#[watch] signal| {
        #[watch]
        let old_signal = (signal) => reg(clk, rst, false, move |_| {
            if signal == T::MIN { T::MAX } else { T::MIN }
        });

        signal <&&> old_signal
   }
   |> Bit::from
)
```
- Добавить возможность подключения синтезированных модулей из других крейтов
- DSL для blackbox evaluate
- Добавить преобразование нод для случая (можно ли как-то организовать код для удобного поиска паттернов в нет листе):
```
/* Automatically generated by Ferrum. */
/*
pub fn top_module(r#in: Signal<TestSystem, Unsigned<4>>) -> Signal<TestSystem, Unsigned<2>> {
    r#in.map(|r#in| {
        let r#in = r#in.repack::<[Bit; 4]>();
        let enc = match r#in {
            [_, _, _, H] => u(0),
            [_, _, H, L] => u(1),
            [_, H, L, L] => u(2),
            _ => u(3),
        };
        enc.into()
    })
}
/*

module top_module
(
    // Inputs
    input wire [3:0] _in,
    // Outputs
    output wire [1:0] __tmp_31
);

    wire [1:0] __tmp_28;
    always @(*) begin
        casez ({ _in[3], _in[2], _in[1], _in[0] }) // <----- convert to _in
            4'b???1 : __tmp_28 = 2'd0;
            4'b??10 : __tmp_28 = 2'd1;
            4'b?100 : __tmp_28 = 2'd2;
            default: __tmp_28 = 2'd3;
        endcase
    end

    wire [1:0] __tmp_31;
    assign __tmp_31 = __tmp_28;

endmodule

```
- Во время добавления ноды проверить, что если предыдущая нода is_pass, то обновить inputs текущей ноды и перекинуть обратные ссылки
- Сериализация/десериализация нет листа
- Вместо повторного вычисления модуля для инлайнинга использовать уже вычисленный и клонировать его ноды (нужно переработать имена для нод)
- Добавить BlackboxTy в SignalTy
- Не учитывать parent generic args в method_call_generics
- Переделать назначение имен для нод (перенести в fhdl_netlist)
- Тесты
- Привязать fhdl lib к nightly тулчейну без указания версии
- Доделать cli для fhdl compiler
- Доработать sim watch
- Добавить возможность записи в vcd
- Конвертация нет листа в формат, используемый для TuringComplete
- Добавить "сброс" нетлиста в виде программы для отдельной симуляции
- Бенчмарки для генерации/симуляции
- `unsafe { with_arena() }` избавиться от unsafe
- нужен ли тип Array
- можно ли сделать поле внутри Unsigned публичным (тогда тип u станет ненужным)
- for loop support
- README / Documentation
- Определиться с типом для ширины сигналов (сейчас используется u128, но это много)
- tracing
- derive SignalValue, BitPack, BitSize
- RefCell for nodes in netlist
- expr complexity for nodes
