use std::io::{Result, Write};

use ferrum_hdl::domain::{Polarity, SyncKind};
use rustc_hash::FxHashSet;

use crate::{
    buffer::Buffer,
    netlist::{Cursor, Module, NetList, NodeId, WithId},
    node::{
        BinOpInputs, Case, DFFInputs, MuxInputs, NetKind, Node, NodeKind, NodeOutput,
    },
    symbol::Symbol,
    visitor::ParamKind,
};

fn write_param<W: Write>(
    buffer: &mut Buffer<W>,
    node_out: &NodeOutput,
    kind: ParamKind,
) -> Result<()> {
    let kind = match kind {
        ParamKind::Input => "input ",
        ParamKind::Output => "output ",
    };

    buffer.write_str(kind)?;
    write_out(buffer, node_out)?;
    buffer.write_fmt(format_args!(" {}", node_out.sym.unwrap()))?;

    Ok(())
}

fn write_out<W: Write>(buffer: &mut Buffer<W>, out: &NodeOutput) -> Result<()> {
    match &out.kind {
        NetKind::Wire => buffer.write_str("wire")?,
        NetKind::Reg => buffer.write_str("reg")?,
    };

    if out.ty.width() > 1 {
        buffer.write_fmt(format_args!(" [{}:0]", out.ty.width() - 1))?;
    }

    Ok(())
}

const SEP: &str = ",\n";

pub struct Verilog<'n, W> {
    pub buffer: Buffer<W>,
    pub locals: FxHashSet<Symbol>,
    pub netlist: &'n NetList,
}

impl<'n, W: Write> Verilog<'n, W> {
    pub fn new(net_list: &'n NetList, writer: W) -> Self {
        Self {
            buffer: Buffer::new(writer),
            locals: Default::default(),
            netlist: net_list,
        }
    }

    fn write_locals(
        &mut self,
        module: &Module,
        node: WithId<NodeId, &Node>,
    ) -> Result<()> {
        let can_skip = !node.is_mod_inst();

        for node_out in node.outputs() {
            let port = node_out.id;
            let is_input = module.is_mod_input(port);
            let is_output = module.is_mod_output(port);
            self.write_local(*node_out, is_input, is_output, can_skip)?;
        }

        Ok(())
    }

    fn write_local(
        &mut self,
        node_out: &NodeOutput,
        is_input: bool,
        is_output: bool,
        can_skip: bool,
    ) -> Result<()> {
        if can_skip && node_out.skip {
            return Ok(());
        }
        let sym = node_out.sym.unwrap();
        let b = &mut self.buffer;

        if !self.locals.contains(&sym) {
            if !(is_input || is_output) {
                b.write_tab()?;
                write_out(b, node_out)?;
                b.write_fmt(format_args!(" {}", sym))?;
                b.write_str(";\n")?;
            }

            self.locals.insert(sym);
        }

        Ok(())
    }

    fn write_mod_span(&mut self, module: &Module) -> Result<()> {
        let b = &mut self.buffer;

        if let Some(span) = module.span() {
            b.write_tab()?;
            b.write_str("// ")?;
            b.write_str(span)?;
            b.write_eol()?;
        }

        Ok(())
    }

    fn write_span(&mut self, node: &Node) -> Result<()> {
        let b = &mut self.buffer;

        if let Some(span) = node.span() {
            b.write_tab()?;
            b.write_str("// ")?;
            b.write_str(span)?;
            b.write_eol()?;
        }

        Ok(())
    }

    pub fn synth(&mut self) -> Result<()> {
        self.buffer
            .write_str("/* Automatically generated by Ferrum HDL. */\n\n")?;

        for module in self.netlist.modules().rev() {
            let module = module.borrow();
            if module.skip {
                continue;
            }

            self.visit_module(&module)?;
        }

        self.buffer.flush()?;

        Ok(())
    }

    fn visit_module(&mut self, module: &Module) -> Result<()> {
        self.locals.clear();
        let is_top = module.is_top;

        self.write_mod_span(module)?;

        let b = &mut self.buffer;

        b.write_fmt(format_args!("module {}\n(\n", module.name))?;

        let mut has_inputs = false;

        // Dont skip inputs if module is top
        let mut inputs = module
            .mod_inputs()
            .iter()
            .filter(|&&input| is_top || !module[input].skip)
            .copied()
            .peekable();

        b.push_tab();
        if inputs.peek().is_some() {
            has_inputs = true;
            b.write_tab()?;
            b.write_str("// Inputs\n")?;

            b.intersperse(SEP, inputs, |buffer, port| {
                buffer.write_tab()?;
                write_param(buffer, &module[port], ParamKind::Input)?;

                Ok(())
            })?;
        }
        b.pop_tab();

        // Dont skip outputs if module is top
        let mut outputs = module
            .mod_outputs()
            .iter()
            .filter(|&&output| is_top || !module[output].skip)
            .copied()
            .peekable();

        b.push_tab();
        if outputs.peek().is_some() {
            if has_inputs {
                b.write_str(SEP)?;
            }
            b.write_tab()?;
            b.write_str("// Outputs\n")?;

            b.intersperse(SEP, outputs, |buffer, port| {
                buffer.write_tab()?;
                write_param(buffer, &module[port], ParamKind::Output)?;

                Ok(())
            })?;
        }
        b.pop_tab();

        b.write_str("\n);\n")?;
        b.write_eol()?;

        b.push_tab();

        let mut nodes = module.nodes();
        while let Some(node_id) = nodes.next(module) {
            let node = &module[node_id];
            if node.skip {
                continue;
            }

            self.visit_node(module, WithId::new(node_id, node))?;
        }

        let b = &mut self.buffer;
        b.pop_tab();

        b.write_str("endmodule\n\n")?;

        Ok(())
    }

    fn visit_node(&mut self, module: &Module, node: WithId<NodeId, &Node>) -> Result<()> {
        self.write_span(*node)?;
        self.write_locals(module, node)?;

        let b = &mut self.buffer;

        match &*node.kind {
            NodeKind::Input(_) => {}
            NodeKind::Pass(pass) => {
                let input = node.with(pass).input(module);
                let input = module[input].sym.unwrap();
                let output = pass.output[0].sym.unwrap();

                b.write_tab()?;
                b.write_fmt(format_args!("assign {output} = {input};\n\n"))?;
            }
            NodeKind::ModInst(mod_inst) => {
                let mod_inst = node.with(mod_inst);
                let orig_mod = self
                    .netlist
                    .module(mod_inst.mod_id)
                    .map(|orig_mod| orig_mod.borrow());
                let name = mod_inst.name;

                b.write_tab()?;

                b.write_fmt(format_args!("{} {} (\n", orig_mod.name, name.unwrap()))?;

                b.push_tab();
                if mod_inst.has_inputs() {
                    b.write_tab()?;
                    b.write_str("// Inputs\n")?;

                    b.intersperse(
                        SEP,
                        module.mod_inst_inputs(mod_inst, orig_mod.as_deref()),
                        |buffer, (mod_inst_input, orig_mod_input)| {
                            if orig_mod_input.skip {
                                return Ok(());
                            }
                            let mod_inst_sym = mod_inst_input.sym.unwrap();
                            let orig_mod_sym = orig_mod_input.sym.unwrap();

                            buffer.write_tab()?;
                            buffer.write_fmt(format_args!(
                                ".{orig_mod_sym}({mod_inst_sym})"
                            ))?;

                            Ok(())
                        },
                    )?;
                }

                if mod_inst.has_outputs() {
                    if mod_inst.has_inputs() {
                        b.write_str(SEP)?;
                    }
                    b.write_tab()?;
                    b.write_str("// Outputs\n")?;

                    b.intersperse(
                        SEP,
                        module.mod_inst_outputs(mod_inst, orig_mod.as_deref()),
                        |buffer, (mod_inst_output, orig_mod_output)| {
                            if orig_mod_output.skip {
                                return Ok(());
                            }

                            let mod_inst_sym = mod_inst_output.sym.unwrap();
                            let orig_mod_sym = orig_mod_output.sym.unwrap();

                            buffer.write_tab()?;
                            buffer.write_fmt(format_args!(
                                ".{orig_mod_sym}({mod_inst_sym})"
                            ))?;

                            Ok(())
                        },
                    )?;
                }

                b.write_eol()?;

                b.pop_tab();
                b.write_tab()?;
                b.write_str(");\n\n")?;
            }
            NodeKind::Const(cons) => {
                let output = cons.output[0].sym.unwrap();
                let value = cons.value;

                b.write_tab()?;
                b.write_fmt(format_args!("assign {output} = {value};\n\n"))?;
            }
            NodeKind::MultiConst(multi_cons) => {
                for (value, output) in multi_cons.val_outputs() {
                    if output.skip {
                        continue;
                    }

                    let output = output.sym.unwrap();

                    b.write_tab()?;
                    b.write_fmt(format_args!("assign {output} = {value};\n\n"))?;
                }
            }
            NodeKind::Splitter(splitter) => {
                let splitter = node.with(splitter);
                let input = splitter.input(module);

                fn write_out<W: Write>(
                    buffer: &mut Buffer<W>,
                    output: &NodeOutput,
                    input: &str,
                    start: u128,
                ) -> Result<()> {
                    let width = output.width();
                    let end = start + width - 1;
                    let output = output.sym.unwrap();

                    buffer.write_tab()?;
                    if width == 1 {
                        buffer.write_fmt(format_args!(
                            "assign {output} = {input}[{start}];\n\n"
                        ))?;
                    } else {
                        buffer.write_fmt(format_args!(
                            "assign {output} = {input}[{end}:{start}];\n\n"
                        ))?;
                    }

                    Ok(())
                }

                let input = module[input].sym.unwrap();

                for (index, output) in splitter.eval_indices(module) {
                    if !output.skip {
                        write_out(b, output, input.as_ref(), index)?;
                    }
                }
            }
            NodeKind::Merger(merger) => {
                let merger = node.with(merger);
                let output = merger.output[0].sym.unwrap();

                b.write_tab()?;
                b.write_fmt(format_args!("assign {output} = {{\n"))?;

                let inputs = merger.inputs(module);

                b.push_tab();
                b.intersperse(
                    SEP,
                    inputs.map(|input| module[input].sym.unwrap()),
                    |buffer, input| {
                        buffer.write_tab()?;
                        buffer.write_fmt(format_args!("{}", input))?;

                        Ok(())
                    },
                )?;
                b.pop_tab();

                b.write_eol()?;
                b.write_tab()?;
                b.write_str("};\n\n")?;
            }
            NodeKind::Extend(extend) => {
                let extend = node.with(extend);
                let input = module[extend.input(module)].sym.unwrap();
                let output = extend.output[0].sym.unwrap();

                b.write_tab()?;
                if !extend.is_sign {
                    b.write_fmt(format_args!("assign {output} = {{ 0, {input} }};\n\n"))?;
                } else {
                    let msb = module[extend.input(module)].width();
                    let w = extend.output[0].width() - msb;
                    let msb = msb.checked_sub(1).unwrap();

                    b.write_fmt(format_args!(
                        "assign {output} = {{ {{ {w}{{ {input}[{msb}] }} }}, {input} }};\n\n"
                    ))?;
                }
            }
            NodeKind::Mux(mux) => {
                let mux = node.with(mux);
                let MuxInputs { sel, cases } = mux.inputs(module);

                let output = mux.output[0].sym.unwrap();
                let sel_sym = module[sel].sym.unwrap();

                b.write_tab()?;
                b.write_fmt(format_args!("always @(*) begin\n"))?;

                b.push_tab();

                b.write_tab()?;
                b.write_fmt(format_args!("case ({sel_sym})\n"))?;

                b.push_tab();

                for (case, input) in cases {
                    match case {
                        Case::Val(case) => {
                            let input = module[input].sym.unwrap();

                            b.write_tab()?;
                            b.write_fmt(format_args!("{case} : {output} = {input};\n",))?;
                        }
                        Case::Default => {
                            let default = module[input].sym.unwrap();

                            b.write_tab()?;
                            b.write_fmt(format_args!(
                                "default: {output} = {default};\n"
                            ))?;
                        }
                    }
                }

                b.pop_tab();

                b.write_tab()?;
                b.write_str("endcase\n")?;

                b.pop_tab();

                b.write_tab()?;
                b.write_str("end\n\n")?;
            }
            NodeKind::BitNot(bit_not) => {
                let bit_not = node.with(bit_not);
                let input = module[bit_not.input(module)].sym.unwrap();
                let output = bit_not.output[0].sym.unwrap();

                b.write_tab()?;
                b.write_fmt(format_args!("assign {output} = ~{input};\n\n"))?;
            }
            NodeKind::BinOp(bin_op) => {
                let bin_op = node.with(bin_op);
                let BinOpInputs { lhs, rhs } = bin_op.inputs(module);
                let lhs = module[lhs].sym.unwrap();
                let rhs = module[rhs].sym.unwrap();
                let output = bin_op.output[0].sym.unwrap();
                let bin_op = bin_op.bin_op;

                b.write_tab()?;
                b.write_fmt(format_args!("assign {output} = {lhs} {bin_op} {rhs};\n\n"))?;
            }
            NodeKind::DFF(dff) => {
                let dff = node.with(dff);
                let DFFInputs {
                    clk,
                    rst,
                    en,
                    init,
                    data,
                } = dff.inputs(module);

                let clk = module[clk].sym.unwrap();
                let data = module[data].sym.unwrap();
                let rst = rst.map(|rst| module[rst].sym.unwrap());
                let en = en.map(|en| module[en].sym.unwrap());
                let init_val = module.to_const(init);
                let output = dff.output[0].sym.unwrap();

                if let Some(init_val) = init_val {
                    b.write_tab()?;
                    b.write_str("initial begin\n")?;

                    b.push_tab();
                    b.write_tab()?;
                    b.write_fmt(format_args!("{output} = {init_val};\n"))?;
                    b.pop_tab();

                    b.write_tab()?;
                    b.write_str("end\n")?;
                }

                b.write_tab()?;
                b.write_fmt(format_args!("always @(posedge {clk}"))?;
                if let Some(rst) = rst {
                    if let SyncKind::Async = dff.rst_kind {
                        let polarity = dff.rst_pol;
                        b.write_fmt(format_args!(" or {polarity} {rst}"))?;
                    }
                }
                b.write_str(") begin\n")?;

                b.push_tab();

                {
                    let mut else_ = false;
                    if let Some(rst) = rst {
                        b.write_tab()?;
                        match dff.rst_pol {
                            Polarity::ActiveHigh => {
                                b.write_fmt(format_args!("if ({rst})\n"))?;
                            }
                            Polarity::ActiveLow => {
                                b.write_fmt(format_args!("if (!{rst})\n"))?;
                            }
                        }

                        b.push_tab();

                        b.write_tab()?;
                        if let Some(init_val) = init_val {
                            b.write_fmt(format_args!("{output} <= {init_val};\n"))?;
                        } else {
                            let init = module[init].sym.unwrap();
                            b.write_fmt(format_args!("{output} <= {init};\n"))?;
                        }

                        b.pop_tab();

                        else_ = true;
                    }

                    let mut pop_tab = false;
                    if let Some(en) = en {
                        b.write_tab()?;
                        if else_ {
                            b.write_fmt(format_args!("else if ({en})\n"))?;
                        } else {
                            b.write_fmt(format_args!("if ({en})\n"))?;
                        }

                        b.push_tab();
                        pop_tab = true;
                    } else if else_ {
                        b.write_tab()?;
                        b.write_str("else\n")?;

                        b.push_tab();
                        pop_tab = true;
                    };

                    b.write_tab()?;
                    b.write_fmt(format_args!("{output} <= {data};\n"))?;

                    if pop_tab {
                        b.pop_tab();
                    }
                }

                b.pop_tab();

                b.write_tab()?;
                b.write_str("end\n\n")?;
            }
        }

        Ok(())
    }
}
